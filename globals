#  Copyright 2021 Google LLC

#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at

#       http://www.apache.org/licenses/LICENSE-2.0

#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

# Display Variables
BLACK='\033[0;30m'
WHITE='\033[1;37m'
CYAN='\033[0;36m'
BCYAN='\033[1;36m'
DCYAN='\033[2;36m'
UCYAN='\033[4;36m' 
RED='\033[0;31m'
BRED='\033[1;31m'
ONRED="\033[41m"  
NC='\033[0m' # No Color
DIVIDER=$(printf %"$(tput cols)"s |tr " " "*") 
DIVIDER+="\n"

function collectParamters(){
    local  __resultvar=$1
    local ARG=$2
    local VALUE=$2
    local LABEL=$3
    local DEFAULT=$4

    if [[ $ARG ]]
    then
        VALUE=$ARG
    else 
        # Allow user to overide the VALUE. 
        printf "Enter $LABEL"
        if  [[ $DEFAULT ]]
        then
            VALUE=$DEFAULT
            printf " [leave blank for ${CYAN}'${DEFAULT}'${NC}]"
        fi
        printf ": "
        read USER_VALUE

        if [[ $USER_VALUE ]]
        then
            VALUE=$USER_VALUE
        fi

    fi

    if [[ !($VALUE) ]]
    then
        printf "\n${BRED}Sorry, $LABEL is mandatory.${NC}\n"
        exit 1;
    fi

    eval $__resultvar="'$VALUE'"
}

# This will handle repetitive collection of data for the contact info
function collectAddressInfo(){
    local  __resultvar=$1
    local LABEL=$2
    local VALUE="$3"
    local NOTE=$4

    printf "Enter your $LABEL"

    if  [[ "$VALUE" != "" ]]
    then
        printf " [leave blank for ${CYAN}'${VALUE}'${NC}]"
    fi
    
    printf "\n"

    if [[ $NOTE ]]
    then
        printf "${ONCYAN}NOTE:${CYAN} $NOTE${NC}\n"
    fi

    printf ":"


    read USER_VALUE

    if [[ $USER_VALUE ]]
    then
        VALUE="$USER_VALUE"
    fi

    if [[ !($VALUE) ]]
    then
        printf "\n${BRED}Sorry, $LABEL is mandatory.${NC}\n"
        exit 1;
    fi

    eval $__resultvar="'$VALUE'"
}

function createProject(){
    local  __resultvar=$1
    local ANSWER
    local PROPOSED_PROJECT_ID
    local BA
    local SUCCESS="false"
    
    section_open "Creating the project"
    while [ "$SUCCESS" == "false" ]
    do
        SUCCESS="true"
        printf "${BCYAN}Please enter a new project name to create: ${NC}\n"
        read PROPOSED_PROJECT_ID
        gcloud projects create $PROPOSED_PROJECT_ID --set-as-default  || SUCCESS="false"

        if [ "$SUCCESS" == "false" ]
        then
            printf "${ONRED}Project name could not be created, please choose another${NC}\n"
            continue
        fi
    done
    gcloud config set project ${PROPOSED_PROJECT_ID}
    section_close

   BA_LIST_GCLOUD=$(gcloud beta billing accounts list --format="value(ACCOUNT_ID)" | xargs)
   IFS=$'\n' read -rd '' -a BA_LIST <<<"$BA_LIST_GCLOUD"

   if [ ${#BA_LIST[@]} == 1 ]
   then
      BA=$BA_LIST_GCLOUD
   else
      printf "${BCYAN}Choose Billing Account from this list${NC}: "
      gcloud beta billing accounts list

      select opt in "${BA_LIST[@]}"
      do
         BA=$opt
         break
      done
   fi
   
   section_open "Activating Billing for the project"
      gcloud beta billing projects link $PROPOSED_PROJECT_ID --billing-account=$BA 
   section_close
   eval $__resultvar="'$PROPOSED_PROJECT_ID'"
}


function selectProject(){
   local  __resultvar=$1
   local PROJ

   PROJECT_LIST_GCLOUD=$(gcloud projects list --format="value(PROJECT_ID)")
   IFS=$'\n' read -rd '' -a PROJECTS <<<"$PROJECT_LIST_GCLOUD"
   PROJECTS=($(for l in ${PROJECTS[@]}; do echo $l; done | sort))
   PROJECTS=("CREATE NEW PROJECT" ${PROJECTS[@]})

   printf "${BCYAN}Choose a project to use for this application. ${NC}\n"
   printf "${ONCYAN}NOTE:${CYAN}: This app will make changes to the project. ${NC}\n"
   printf "While those changes are reverseable, it would be better to put it in a fresh new project. \n"

   select opt in "${PROJECTS[@]}"
   do
      if [[ "$opt" == "CREATE NEW PROJECT" ]]
      then
         createProject PROJ
      else
         PROJ=$opt
         gcloud config set project ${PROJ}
      fi
      break
   done

   eval $__resultvar="'$PROJ'"
}


function handleProject {
   local  __resultvar=$1
   local ARG=$2
   local VALUE

   if [[ $ARG ]]
   then
      VALUE=$ARG
   else
      selectProject VALUE
   fi 

   eval $__resultvar="'$VALUE'"
}


function computeRegionPicker(){
   local  __resultvar=$1
   local ARG=$2
   local REG
   local REGIONS

   if [[ $ARG ]]
   then
      REG=$ARG
      eval $__resultvar="'$REG'"
      return
   fi 

   printf "Poling for regions...\n"

   REGION_LIST_GCLOUD=$(gcloud compute regions list --format="value(NAME)")
   IFS=$'\n' read -rd '' -a REGIONS <<<"$REGION_LIST_GCLOUD"
   REGIONS=($(for l in ${REGIONS[@]}; do echo $l; done | sort))

   printf "${BCYAN}Choose a valid region to use for this application. ${NC}\n"

   while [ "$REG" == "" ]
   do 
      select opt in "${REGIONS[@]}"
      do
         REG=$opt
         break
      done
   
       if [ "$REG" == "" ]
        then
            printf "${ONRED}REGION choice not valid, please choose another${NC}\n"
            continue
        fi
   done
   eval $__resultvar="'$REG'"

}

function computeZonePicker(){
   local __resultvar=$1
   local ARG=$2
   local REG=$3
   local Z
   local ZONES

   if [[ $ARG ]]
   then
      Z=$ARG
      eval $__resultvar="'$Z'"
      return
   fi 
   printf "Poling for zones...\n"
   ZONES_LIST_GCLOUD=$(gcloud compute zones list --filter=region=$REG --format="value(NAME)")
   IFS=$'\n' read -rd '' -a ZONES <<<"$ZONES_LIST_GCLOUD"
   ZONES=($(for l in ${ZONES[@]}; do echo $l; done | sort))

   printf "${BCYAN}Choose a valid zone to use for this application. ${NC}\n"

   while [ "$Z" == "" ]
   do
      select opt in "${ZONES[@]}"
      do
         Z=$opt
         break
      done
   
       if [ "$Z" == "" ]
        then
            printf "${ONRED}ZONE choice not valid, please choose another${NC}\n"
            continue
        fi
   done

   eval $__resultvar="'$Z'"

}


function section_open(){
      section_description=$1
      printf "$DIVIDER"
      printf "${CYAN}$section_description${NC} \n"
      printf "$DIVIDER"
}

function section_close(){
      printf "$DIVIDER"
      printf "${CYAN}$section_description ${BCYAN}- done${NC}\n"
      printf "\n\n"
}

function print_title(){
	printf "$DIVIDER"
	printf "${BCYAN}$1${NC} \n"
	printf "$2\n"
	if [ $3 = 1 ]
	then
		printf "It's going to take around ${CYAN}1 min${NC} \n"
	else
		printf "It's going to take around ${CYAN}$3 mins${NC} \n"
	fi
	
	printf "$DIVIDER"
}

function get_project_id(){
    local  __resultvar=$1
    VALUE=$(gcloud config get-value project | xargs)
    eval $__resultvar="'$VALUE'"
}

function get_project_number(){
    local  __resultvar=$1
    local PRO=$2

    VALUE=$(gcloud projects list --filter="$PRO" --format="value(PROJECT_NUMBER)" | xargs)	
    eval $__resultvar="'$VALUE'"
}

function get_build_serviceaccount(){
    local  __resultvar=$1
    local NUMBER=$2
    VALUE=$NUMBER@cloudbuild.gserviceaccount.com
    eval $__resultvar="'$VALUE'"
}

function get_compute_serviceaccount(){
    local  __resultvar=$1
    local NUMBER=$2
    VALUE=$NUMBER-compute@developer.gserviceaccount.com
    eval $__resultvar="'$VALUE'"
}

function get_run_url(){
    local  __resultvar=$1
    local NAME=$2
    local REGION=$3
    VALUE=$(gcloud run services describe $NAME --region=$REGION --format="value(status.url)" | xargs)
    eval $__resultvar="'$VALUE'"
}


function await_command () {
    local  __resultvar=$1
    local DURATION=$2
    local limit=$3
    local OP=$4
    local NAME=$5
    local REGION=$6
    local DOMAIN=$5
    local IP=$6
    


    case $OP in
        "sqlIP")
            COMMAND="gcloud beta sql instances describe"
            FORMAT="--format='value(ipAddresses[0].ipAddress)'"
            MESSAGE="Checking if IP is available"
            AWAITING="!BLANK"
            ERROREXPECTED=false
        ;;

        "sqlREADY")
            COMMAND="gcloud beta sql instances describe"
            FORMAT="--format='value(state)'"
            MESSAGE="Checking if database is up"
            AWAITING="RUNNABLE"
            ERROREXPECTED=false
        ;;

        "redisIP")
            COMMAND="gcloud redis instances describe"
            FORMAT="--region=$REGION --format='value(host)'"
            MESSAGE="Checking if IP is available"
            AWAITING="!BLANK"
            ERROREXPECTED=false
        ;;

        "redisGone")
            COMMAND="gcloud redis instances describe"
            FORMAT="--region=$REGION --format='value(host)'"
            MESSAGE="Checking if Redis server is gone"
            AWAITING=""
            ERROREXPECTED=true
        ;;

        "domainREADY")
            COMMAND="gcloud beta domains registrations describe"
            FORMAT="--format='value(state)'"
            MESSAGE="Checking if domain is active "
            AWAITING="ACTIVE"
            ERROREXPECTED=false
        ;;

         "url200")
            COMMAND="curl --write-out '%{http_code}' --resolve $DOMAIN:80:$IP --silent --output /dev/null http://$DOMAIN"
            FORMAT=""
            MESSAGE="Checking if url is returning STATUS OK "
            AWAITING=200
            NAME=""
            ERROREXPECTED=false
        ;;

        *)
            echo "Unknown Operation Type"
            exit 1
        ;;
    esac

    ERROR=false
    VALUE=$(eval $COMMAND $NAME $FORMAT) || ERROR=true

    if [ "$ERROR" = true ]
    then
        if [ "$ERROREXPECTED" == true ]
        then 
            printf "\n"
            eval $__resultvar=""
            return 1
        fi
        printf "Command to poll errored. Exiting\n"
        return 1
    fi

    i=0
    if [ "$AWAITING" = "!BLANK" ]
    then
        while [ "$VALUE" = "" ]
        do

            i=$(( $i + 1 ))
            if [ $i -eq 1 ]
            then
                printf $MESSAGE
            fi

            if [ $i -eq $limit ]
            then
                printf "Timed out \n"
                return 1
            fi

            VALUE=$(eval $COMMAND $NAME $FORMAT) || ERROR=true
            if [ "$ERROR" = true ]
            then
                if [ "$ERROREXPECTED" == true ]
                then 
                    printf "\n"
                    eval $__resultvar="''"
                    return 1
                fi
                printf "Command to poll errored. Exiting\n"
                return 1
            fi
            printf "."
            sleep $DURATION
        done
    else
        while [ "$VALUE" != "$AWAITING" ]
        do
            i=$(( $i + 1 ))
            if [ $i -eq 1 ]
            then
                printf $MESSAGE
            fi

            if [ $i -eq $limit ]
            then
                printf "Timed out \n"
                return 1
            fi

            VALUE=$(eval $COMMAND $NAME $FORMAT) || ERROR=true

            if [ "$ERROR" = true ]
            then
                if [ "$ERROREXPECTED" == true ]
                then 
                    printf "\n"
                    eval $__resultvar="''"
                    return 1
                fi
                printf "Command to poll errored. Exiting\n"
                return 1
            fi
            printf "."
            sleep $DURATION
        done
    fi
    printf "\n"
    eval $__resultvar="'$VALUE'"
}


function evalTest(){
    local command=$1
    local expected=$2

    local ERR=""
    got=$(eval $command 2> errFile)
    ERR=$(<errFile)

    if [ ${#ERR} -gt 0 ]
    then
        if [ "$expected" = "EXPECTERROR" ]
        then
            printf "Expected Error thrown \n"
            return
        fi

         printf "Halting - error: '$ERR'  \n"
         exit 1
    fi

    if [ "$got" != "$expected" ]
    then
        printf "Halting: '$got'  \n"
        exit 1
    fi

    printf "$expected is ok\n"
}


function randomString(){
    local  __resultvar=$1
    local VALUE=$(LC_ALL=C tr -dc 'a-z0-9' </dev/urandom | head -c 13 ; echo)
    eval $__resultvar="'$VALUE'"
}